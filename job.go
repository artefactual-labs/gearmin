package gearmin

import (
	"fmt"
	"os"
	"strconv"
	"sync"
	"sync/atomic"
	"time"
)

const jobHandlePrefix = "H:"

type job struct {
	Handle      string            // Identifier generated by the job server.
	FuncName    string            // Function name.
	ID          string            // Client-provided identifier (see "coalescing").
	Data        []byte            // Job payload.
	Background  bool              // Whether this is a background job.
	CreatedAt   time.Time         // Timestamp of when the job was created.
	Running     atomic.Bool       // Whether the job is still running.
	ProcessedAt time.Time         // Timestamp of when the worker completed the job.
	ProcessedBy int64             // Session identifier of the worker processing it.
	Callback    JobUpdateCallback // User-provided callback.
}

type JobUpdateType int

const (
	JobUpdateTypeData JobUpdateType = iota
	JobUpdateTypeWarning
	JobUpdateTypeStatus
	JobUpdateTypeComplete
	JobUpdateTypeFail
	JobUpdateTypeException
)

func (t JobUpdateType) String() string {
	switch t {
	case JobUpdateTypeData:
		return "JobUpdateTypeData"
	case JobUpdateTypeWarning:
		return "JobUpdateTypeWarning"
	case JobUpdateTypeStatus:
		return "JobUpdateTypeStatus"
	case JobUpdateTypeComplete:
		return "JobUpdateTypeComplete"
	case JobUpdateTypeFail:
		return "JobUpdateTypeFail"
	case JobUpdateTypeException:
		return "JobUpdateTypeException"
	}
	return ""
}

type JobUpdate struct {
	Type   JobUpdateType
	Handle string
	Status [2]int // Status numerator and denominator.
	Data   []byte // Opaque data (nil if the update type does not include data).
}

func (u JobUpdate) Succeeded() bool {
	return u.Type == JobUpdateTypeComplete
}

func (u JobUpdate) Failed() bool {
	return u.Type == JobUpdateTypeFail || u.Type == JobUpdateTypeException
}

type JobUpdateCallback func(update JobUpdate)

type jobHandleGenerator struct {
	start  int64
	prefix string
	once   sync.Once
}

var (
	hostname = os.Hostname
	now      = time.Now
	pid      = os.Getpid
)

func (j *jobHandleGenerator) jobHandle() string {
	j.once.Do(func() {
		hn, err := hostname()
		if err != nil {
			hn = os.Getenv("HOSTNAME")
		}
		if hn == "" {
			hn = "localhost"
		}
		j.prefix = fmt.Sprintf("%s%s:%d-%d-", jobHandlePrefix, hn, pid(), now().Unix())
	})

	new := atomic.AddInt64(&j.start, 1)
	return j.prefix + strconv.FormatInt(new, 10)
}
